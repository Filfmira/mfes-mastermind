class Jogo
types
	public String = Utilities`String;
	
values
-- TODO Define values here

instance variables
	private tabuleiros : map String to Tabuleiro; -- um para cada equipa
	inv card (dom tabuleiros) = 2;
	
operations
	public Jogo : map String to seq1 of Cor`Cor * Campeonato ==> Jogo
	Jogo (chaves, campeonato) == (
		let {jogador1, jogador2} = dom chaves in
			tabuleiros := {jogador1 |-> new Tabuleiro(chaves(jogador2)),
				jogador2 |-> new Tabuleiro(chaves(jogador1))};
		)
	pre card (dom chaves) = 2 and
		forall jogador in set dom chaves &
			jogador in set campeonato.getJogadores() and
		forall chave in set rng chaves &
			len chave = Tabuleiro`comprimentoChave
	post forall jogador in set (dom tabuleiros) &
		let adversario = dom chaves \ {jogador} in
			{tabuleiros(jogador).getChave()} = rng (adversario <: chaves);
			--chave do tabuleiro da  minha equipa == chave gerada pelo adversario


	-- Constructor needed to recreate a game from the information of a file
	public Jogo : map String to Tabuleiro ==> Jogo
	Jogo (tabuleirosFicheiro) ==
		tabuleiros := tabuleirosFicheiro
	pre card (dom tabuleirosFicheiro) = 2
	post tabuleiros = tabuleirosFicheiro;

	public getTabuleiros : () ==> map String to Tabuleiro
	getTabuleiros () == return tabuleiros
	post RESULT = tabuleiros;

	pure public getJogadores : () ==> set of String
	getJogadores () == return dom tabuleiros
	post RESULT = dom tabuleiros;


	public getTabuleiroJogador : String ==> Tabuleiro
	getTabuleiroJogador (jogador) == return tabuleiros(jogador)
	post RESULT = tabuleiros(jogador);


	public getTabuleiroAdversario : String ==> Tabuleiro
	getTabuleiroAdversario (jogador) ==
		let adversario in set (dom tabuleiros)\{jogador}
		in
		return tabuleiros(adversario)
	pre jogador in set (dom tabuleiros)

	post RESULT in set rng tabuleiros
		and {RESULT} = rng ({jogador} <-: tabuleiros);
		
		
functions
-- TODO Define functiones here
traces
-- TODO Define Combinatorial Test Traces here
end Jogo